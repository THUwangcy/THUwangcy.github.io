<!DOCTYPE html>
<html>

<head>
	<!-- Meta -->
	<meta charset="UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<meta name="generator" content="Jekyll">

	<title>2017实习总结</title>
  <meta name="description" content="2017年实习经历的总结，申请了Google、依图和腾讯实习小学期，最后实际去的是腾讯和依图。这篇文章整理了最初的面试准备，面试题解以及实习过程中的体会与对比。">

	<!-- CSS & fonts -->
	<link rel="stylesheet" href="/css/main.css">

	<!-- RSS -->
	<link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/png" href="img/favicon.png">

</head>


<body>
	<div id="wrap">
	  	
	  	<!-- Navigation -->
	  	<nav id="nav">
	<div id="nav-list">
		<a href="/">Home</a>

		<!-- Nav pages -->
	  
	    
	  
	    
	      <a href="/about" title="About">About</a>
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
    
    <!-- Nav links -->
	  <a href="\categories.html">Categories</a>
<a href="\tags.html">Tags</a>
<a href="https://github.com/THUwangcy">Github</a>


	</div>
  
  <!-- Nav footer -->
	
	  <footer><span>@2018 - Chenyang Wang's Blog</span></footer>

	

</nav>

    
    <!-- Icon menu -->
	  <a id="nav-menu">
	  	<div id="menu"></div>
	  </a>

      <!-- Header -->
      
        <header id="header" class="parent justify-spaceBetween">
  <div class="inner w100 relative">
    <span class="f-left">  
      <a href="/">
        <h1>
          <span>Chenyang Wang's </span> Blog
        </h1>
      </a>
    </span>
    <span id="nav-links" class="absolute right bottom">
      <a href="/">Home</a>

      <!-- Nav pages -->
	    
	      
	    
	      
	        <a href="/about" title="About">About</a>
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
      
      <!-- Nav links -->
	    <a href="\categories.html">Categories</a>
<a href="\tags.html">Tags</a>
<a href="https://github.com/THUwangcy">Github</a>


    </span>
  </div>
</header>




      

    <!-- Main content -->
	  <div id="container">
		  
		<main>

			<article id="post-page">
	<h2>2017实习总结</h2>		
	<time datetime="2018-02-12T00:00:00+08:00" class="by-line">12 Feb 2018
        
            &emsp;浏览量: 
            <span id="/2017%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93" class="leancloud_visitors" data-flag-title="2017实习总结">
                <span class="leancloud-visitors-count"></span>
            </span>次
        
    </time>
	<div class="content">

		<p>2017年在实习方面经历了挺多，先后申请了Google、依图的暑期实习以及腾讯的实习小学期。最后的结果是Google挂在了终面，依图和腾讯通过了，于是暑假7月至8月在腾讯实习了一个多月，回北京后上课的同时在依图实习了三个月，到11月实习的种种算是告一段落。</p>

<p>在这个过程中，经历了很多，从最初面试的准备，到第一次实习面试，再到真正实习所做的事情和学到的东西，也算是有不少感悟。下面就总结一下这一年的实习经历，主要分两个部分，第一个部分包括面试的准备和面试后整理的题解；第二部分包括实习过程中的评价、对比等。</p>

<h2 id="面试准备">面试准备</h2>

<hr />

<h3 id="google"><strong>Google</strong></h3>

<p>最初萌生实习的想法是在大三上期末的时候，也就是2017年初，看到了Google暑期实习的招聘，一直以来没有经历过实习，挺好奇实习究竟是什么样的，于是就报了名。当时找了系里去实习过的同学内推，所以算是提前批，没有笔试，直接面临的就是第一轮电话面试。</p>

<ul>
  <li><strong>电话面试</strong></li>
</ul>

<p>由于是第一次报名实习，没有任何面试经验，对这种技术面很没有信心，所以前期做了挺多准备。首先是了解面试流程，问了一些面试过的同学，并且找了网上的面经，对整个流程基本有了了解。简单来说，就是面试官在约定时间打来电话，首先简单自我介绍一下，面试官可能会针对简历问几个问题，然后最主要的是面试官出一道算法题，在时限内解答出来，期间不断跟面试官交流思路，最后现场把code写到共享文档中，不能本地调试，就像白板写代码。如果时间还有剩余的话可以问面试官一两个感兴趣的问题，整个流程时间为45min。</p>

<p>下面关键就是如何在面试过程中把题目解出来了，为此开始刷leetcode，上面的题目难度感觉还是比较合适的，并且community很活跃，对于难题想不出来的，都会有人给出详细的题解，从中得到了不少启发，最重要的还是练了个手熟，至少常见的二分及变体能做到心中很明朗，很快能无误地写出来。寒假期间到面试前大概刷了50到100道吧，也没刷太多。</p>

<p>约定的面试时间是2月15号，之前会有各种邮件交代注意事项，还会发视频教你熟悉面试流程和技巧，Google招聘的工作做得确实不错，各种提醒感到很温暖。面试的日子很快如期而至，幸运的是面试官很nice，上来什么都没问直接开始做题，并且做题过程中会一直给出引导，后来算是顺利地做出来了。具体题目有些记不清了，时间有点久，努力回忆了一下好像是这样的：</p>

<blockquote>
  <p>给定一个长度为 $n$ 的有序整数数组 $X$，以及一个整数 $C$，求这个数组所有长度为 $ k $ 的窗口中，哪个窗口中所有数与 $C$ 的绝对值之差的和最小。</p>
</blockquote>

<p><strong>方法一</strong></p>

<p>拿到这个题最朴素的想法就是枚举所有的窗口，共 $n-k+1$ 个，每个窗口计算绝对值之差的和是$O(k)$的，总复杂度$O((n-k+1)k)$，这个复杂度至少是$O(n)$的，最差情况下是$O(n^2)$级别了。</p>

<p><strong>方法二</strong></p>

<p>这种方法完全没利用上有序的条件，有序数组通常会想到二分，考虑到数组中最接近 $C$ 的数一定在窗口中，因此第二个想到的方法就是先二分找到数组 $X$ 中最接近 $C$ 的数，然后以此为中心左右两个指针向两边扩展，每次纳入两边两个数中更接近 $C$ 的，直到窗口长度达到 $k$。这样总复杂度为$O(logn+k)$，看起来比第一个方法要好，特别是 $k$ 比较小时。但如果 $k$ 很大，接近 $n$ 的级别，这个方法复杂度也有$O(n)$级别。</p>

<p><strong>方法三</strong></p>

<p>那么如何找到$O(logn)$级别的做法呢。如果把 $X$ 中的每个数减去 $C$ 取绝对值构成的新数列记作 $X’$，那所求即 $X’$ 中哪个长度为 $k$ 窗口里的数之和最小。容易想到 $X’$ 是先减后增的（也可能是一直递减或一直递增的，但属于特殊情况，容易处理，这里考虑一般情况），并且关键的一点是，如果考虑窗口从左端滑到右端，这个窗口的和也是先减后增的，我们要找的就是减到最低的低谷，也就是所求和最小的窗口。</p>

<p>这样如果把窗口从左到右滑动时每个窗口的和依次构成一个先减后增的数列（长度为 $n-k+1$），问题就转化成求这个数列的最小值，可以用二分法来做。但是问题在于每次二分对于中点要求出对应窗口的和，这一步是$O(k)$的，总复杂度就是$O(klog(n-k+1))$，还是不行。如果考虑用前缀和的思想，先求出 $X’$ 的前缀和，这样可以在$O(1)$ 的时间里得到任意窗口的和，但求前缀和本身就是$O(n)$的了，并不可行。</p>

<p><strong>方法三改进</strong></p>

<p>那怎么办呢，考虑我们二分的目标，是要在一个先减后增的数列中找到第一个比下一个数小的数，所以每次在中点判断时只需要判断中点的数是否比下一个数小，是了，就到中点左边找；不是，就到中点右边找。而判断一个窗口的和是否比下一个窗口的和小并不需要把这两个窗口的和都计算出来，下一个窗口相当于只是去掉了上一个窗口的第一个数，又增添了上一个窗口后面的一个数，其他都是一样的，因此只需要比较这两个数谁大谁小，就可以判断窗口的和的大小了。这一步操作直接取数比大小是$O(1)$的，总复杂度即为二分的复杂度$O(log(n-k+1))$。</p>

<p>最后这个方法的关键就在于观察到了目标值先减后增的特性，再根据二分时判断条件的特性减少不必要的和的计算。总体来说属于二分法的一个变形，但题目还是挺有意思的，难度适中，现场白板写代码也有不少要注意的细节，考验了基本功。面完后庆幸自己做了leetcode，二分法写起来非常熟练，不然如果裸上，即使有了最后这个思路也不一定能在现场写出来。</p>

<ul>
  <li><strong>现场面试</strong></li>
</ul>

<p>电话面试结束后马上就来电话通知过了，可以准备参加现场面试，时间就在大三下开学第一周。现场面更加紧张，第一次来到Google的大楼，看到了Google内部的工作环境，确实令人向往，能看出内部的企业文化建设得挺不错。可惜这次面试跪了，被面试官带到一个会议室进行的面试，这个面试官虽然和蔼但感觉很不专业，有些思路要解释半天他才明白，并且解题过程中没有给出任何有引导性的建议。不过还是自身实力不够，最后一道题没解出来。回来后又和黄大大、韦师讨论了下，这里整理整理思路。</p>

<p>现场面试和电话面不太一样，这次有了自我介绍和问简历，并且不只一道题。前两题都很简单，刚开始不知道有多道题一直在想第一题是不是有什么陷阱，谁知道就是一些简单题。前两题是关于二叉树遍历和字符串数字减法的，每道题都需要写代码，感觉就是考察一下基本功，思路上没什么说的。</p>

<p>第三题就开始不一样了，题目印象还比较深（毕竟没做出来）：</p>

<blockquote>
  <p>有 $n$ 个人排队，每个人都知道自己的身高和队伍前面有几个比自己高的人，现在队伍解散，要求根据每人所知道的两个信息把之前的队伍顺序重建出来。</p>
</blockquote>

<p><strong>方法一</strong></p>

<p>朴素做法，枚举所有排列再验证，复杂度$O(n!)$，无法接受。</p>

<p><strong>方法二</strong></p>

<p>这类题容易想到先按身高排序，再依照身高的顺序从低到高或者从高到低安排每个人的位置。排序是$O(nlogn)$的，因此这道题复杂度最低也是$O(nlogn)$级别了。</p>

<p>下面考虑如何安排位置，当时在面试现场想到的是一种从高到低的方法：</p>

<ul>
  <li>假设有一个可变长度的数组，初始长度为0。</li>
  <li>首先插入身高最高的人，数组长度变为1；</li>
  <li>接着对于第二高的人，他前面比他高的人只可能是1个或0个，根据这个信息可以确定把他插入到第一个后面还是前面；</li>
  <li>对于第三高的人，他前面比他高的人可能是0、1、2个，据此也可确定把他插入到之前两个人的前面、中间还是后面；</li>
  <li>一般来说，对于第 $k$ 高的人，前面比他高的人只可能是0到 $k-1$ 个。此时数组中有 $k-1$ 个人，并且都比他高，根据比他高的人的个数可以唯一确定插入的位置；</li>
  <li>如此将 $n$ 个人全部插入数组，即得到原来的队伍顺序。</li>
</ul>

<p>这个方法的关键在于如何把新的人插入到数组指定位置，用数组或者链表的话插入都是$O(n)$的，插入$~n~$次复杂度就为$O(n^2)$。当时现场我想的就止步于此，没有往树的方向想，其实这个方法用平衡树就是$O(nlogn)$的了，平衡树（比如C++的map所用的红黑树）的插入就是$O(logn)$的。不过确实当时没怎么复习树那一块，没有朝那边想的思路，面试官也一点都没有引导，就这样跪在了这道题。但其实这种方法不算很优，如果现场要写代码并且不允许用STL容器的话，手写平衡树是不太现实的。</p>

<p><strong>方法三</strong></p>

<p>回来之后和韦师讨论过一种可写的方法，用的是线段树，从低到高安排每个人的位置：</p>

<ul>
  <li>初始有$~n~$个位置，都是空闲的。</li>
  <li>对于最低的人，根据他前面比他高的人数$~x~$，可以确定他的位置是第$~x+1~$个空闲位置，安排了人的位置记为不空闲;</li>
  <li>对于第$~k~$低的人，假设前面比他高的人有$~x_k~$个，那么就是从前往后找第$~x_k+1~$个空闲位置，这个位置就是他原来的位置。</li>
</ul>

<p>用线段树维护每个区间的空闲位置的话，每个节点保存对应区间空闲位置的个数。假设要查询的空闲位置是第$~k~$个，对每个节点，如果左孩子对应区间空闲位置个数$~n_l\ge k~$，则递归到左孩子查询第$~k~$个，否则递归到右孩子查询第$~k-n_l~$个。这样查询位置是$O(logn)$的，之后修改空闲位置的情况，只需要修改查询路线上的$logn$个节点。总体复杂度为$O(nlogn)$。</p>

<p>面试后两周拿到的结果为待定，又过了一段就确定跪了。总体来说感觉Google的现场面有点可惜，不过第一次申请实习的面试，就当提高知识水平了，有一点气馁但也没持续很长时间。</p>

<h3 id="依图">依图</h3>

<p>Google的面试跪掉之后，偶然的机会看到了依图的实习招募推送，一家做人工智能应用的公司，人脸识别很厉害，属于新兴的创业公司，发展很迅速。之前也听说过几个学长学姐推荐这里，说虽然工作强度大但学到的东西很多，于是就投了简历，正好能找在那工作的学长内推，直接面试。其实当时投的时候有点犹豫，感觉公司名气不大，第一次实习还是想找一个Big Name实习。但经历Google的失败后，感觉大公司的面试都不怎么简单，思来想去，本着学习知识的想法还是投了。</p>

<ul>
  <li><strong>一面</strong></li>
</ul>

<p>一面是电话面试，我没准备就上了，想着过了就过了，没过也就算了。流程也很普遍，简单的自我介绍和简历问答后，就是做题加现场写代码。问题很简单：</p>

<blockquote>
  <p>$O(logn)$的时间复杂度求斐波那契数列第$~n~$项</p>
</blockquote>

<p>正常用动态规划自底向上应该是$O(n)$的复杂度。$O(logn)$的做法其实有印象，用矩阵快速幂，问题的关键在于找到如下传递关系</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{bmatrix} f(n) & f(n-1) \end{bmatrix}=\begin{bmatrix} f(n-1) & f(n-2) \end{bmatrix}\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix} %]]></script>

<p>如此一来求$f(n)$就可表示为</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{bmatrix} f(n) & f(n-1) \end{bmatrix}=\begin{bmatrix} f(1) & f(0) \end{bmatrix}\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}^{n-1}~~(n > 0) %]]></script>

<p>问题转化为求转移矩阵的$~n-1~$次方，用快速幂的方法可以在$O(logn)$时间内求得。</p>

<p>当时写代码时快速幂出了一点小bug被指出来了，不过也算顺利通过了。</p>

<ul>
  <li><strong>二面</strong></li>
</ul>

<p>二面本来要求去上海面试的，但我以上课为由也改成电话面试了。二面的题感觉是一道智力题：</p>

<blockquote>
  <p>有100层楼，2个同样的玻璃杯，玻璃杯在某一层摔下来恰好会摔碎（在比这一层更高的楼层都会碎，比这一层更低的楼层都不会碎），求在最差情况下，最少摔多少次可以保证能测出这一层是哪一层。</p>
</blockquote>

<p>如果一层往上摔，最差要摔100次；考虑用二分的方法，第一次在50层摔，如果碎了并且目标层数是49，那么下一个杯子要从第一层往上摔，最差一共50次。因此可以看出这道题并不适合二分方法。</p>

<p>这道题其实正着想并不好想，越想越乱，解决问题的关键在于一步问题转化：</p>

<blockquote>
  <p>有两个玻璃杯，给你$~n~$次机会，最多可以<strong>保证</strong>测出多少层</p>
</blockquote>

<p>让<strong>保证</strong>能测出的层数大于等于100，此时的$~n~$即是最小的次数。要注意的一点是这里要<strong>保证</strong>最多测出多少层，容易得到第一次一定要在第$~n~$层摔，如果第一次摔碎了，我们还有剩下的$~n-1~$次机会在下面的$~n-1~$层依次尝试确定到底是哪一层；如果第一次没摔碎，则问题变为$~n-1~$次机会最多可以保证测出多少层。</p>

<p>从$~n~$比较小时出发举几个例子：</p>

<ul>
  <li>$n=1$时，只能测出1层，因为只有1次机会</li>
  <li>$n=2$时，第一次在第2层摔，没摔碎的话问题退化为$n=1$的情况，即还能在第2层基础上向上测出1层。故此时最多保证测出$2+1=3$层</li>
  <li>$n=3$时，第一次在第3层摔，没摔碎的话问题退化为$n=$2的情况，即还能在第3层基础上向上测出3层。故此时最多保证测出$3+3=6$层</li>
</ul>

<p>由以上可以看出，如果记$~n~$次机会最多可以保证测出的层数为$f(n)$，则
<script type="math/tex">f(n)=n+f(n-1)~~(n>1)</script>
并且$~f(1)=1~$，由此可得$~f(n)~$的通式
<script type="math/tex">f(n)=1+2+\cdots +n=\dfrac{(1+n)n}{2}</script>
令$~f(n)\ge 100~$可得$~n\ge 14~$，故最少摔14次可以保证在最差情况下也能测出层数。</p>

<ul>
  <li><strong>三面</strong></li>
</ul>

<p>三面极其水，首先面试官都迟到了半个小时，问了好几个问题，不需要写代码，具体问题不记得了，因为都很简单。最后一道难题只记得是leetcode第4题的变种，就是两个有序数组求合一起的中位数（<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/">题目</a>及<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2481/Share-my-O(log(min(mn))-solution-with-explanation">解法</a>），具体怎么变种的没印象了。这个题因为做过就直接秒了，整个面试20分钟结束了。</p>

<p>三面后就通知拿到了offer，依图这边的面试告一段落。腾讯那边则因为是学校的小学期所以没有面试。</p>

<p>这样第一部分面试准备基本就到这里。不得不说整个面试准备的过程让我复习了很多之前学的知识，也学习到很多新的思路，收获挺大的。</p>

<h2 id="实习体验">实习体验</h2>

<hr />

<p>由于最后只去了腾讯和依图，这里只谈谈我对这两家公司的感受。</p>

<ul>
  <li><strong>腾讯</strong></li>
</ul>


		
	</div>
</article>



	  </main>
		
		  <!-- Pagination links -->
      

	  </div>
	    
	    <!-- Footer -->
	    <footer><span>@2018 - Chenyang Wang's Blog</span></footer>


      <!-- Script -->
      <script src="/js/main.js"></script>	

<script 
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    inlineMath: [['$','$']]
  }
});
</script>


  <script src="https://code.jquery.com/jquery-3.2.0.min.js"></script>
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("a7bTOQ5loeIl2rs7AINQHmIF-gzGzoHsz", "IgdEvbu6cnslDdC5MNpYK2ni");</script>
  <script>
    function showHitCount(Counter) {
      /* 这是给一个页面中有多篇文章时所调用的，例如博客主界面或者存档界面。
      */
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      // 获取页面中所有文章的id（page.url）
      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      // 批量查询
      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var hits = item.get('hits');// 获取点击次数
            var element = document.getElementById(url);

            // 显示点击次数
            $(element).find(COUNT_CONTAINER_REF).text(hits);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      // 页面（博客文章）中的信息：leancloud_visitors
      // id为page.url， data-flag-title为page.title
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      // 只根据文章的url查询LeanCloud服务器中的数据
      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {//说明LeanCloud中已经记录了这篇文章
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("hits");// 将点击次数加1
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('hits'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            // 执行这里，说明LeanCloud中还没有记录此文章
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);// 把文章标题
            newcounter.set("url", url); // 文章url
            newcounter.set("hits", 1); // 初始点击次数：1次
            newcounter.save(null, { // 上传到LeanCloud服务器中
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('hits'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        // in post.html, so add 1 to hit counts
        addCount(Counter);
      } else {
        // in index.html, there are many 'leancloud_visitors' and 'post-link', so just show hit counts.
        showHitCount(Counter);
      }
    });
  </script>



	</div>
</body>
</html>
